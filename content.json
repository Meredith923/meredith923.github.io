{"meta":{"title":"Meredith923","subtitle":"浪漫批","description":"Time tries all.","author":"苒耀晨","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-05-27T17:47:07.463Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-05-27T17:47:07.464Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2022-05-28T15:13:48.000Z","updated":"2020-05-27T19:13:12.863Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"SUBURBIA Have you heard me on the radio,did you turn it up? 一首高三单曲循环过的一首troye的歌，描述他的故乡澳大利亚珀斯","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-05-27T17:47:07.465Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-05-27T17:47:07.464Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-05-27T17:47:07.465Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-05-28T00:58:53.547Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-05-27T17:47:07.466Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-05-27T17:47:07.466Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-05-28T00:30:39.294Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"苒耀晨的博客 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-05-27T17:47:07.467Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-05-28T00:50:21.260Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-05-27T17:21:22.951Z","updated":"2020-05-27T17:21:22.951Z","comments":true,"path":"2020/05/28/hello-world/","link":"","permalink":"/2020/05/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"枚举类型","slug":"枚举类型","date":"2019-11-29T14:16:01.000Z","updated":"2020-05-28T05:16:57.433Z","comments":true,"path":"2019/11/29/枚举类型/","link":"","permalink":"/2019/11/29/枚举类型/","excerpt":"","text":"枚举类型 enum #一、枚举类型的定义枚举类型(enumeration)：是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 Enum 枚举类型名 {变量值列表}； enum：关键字，指明其后的标识符是一个枚举类型的名字 变量值列表：由枚举常量构成，通常用逗号隔开 ###【解析】如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓“枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。声明枚举类型用enum开头。 #二、枚举类型的应用说明# 对枚举元素常按照常量处理，不能对他们赋值# # Enum Weekday {SUM,MON,TUE,WED,THU,FRI,SAT}; //定义枚举类型 SUM=0; //SUM是枚举类型，此语句非法 枚举元素具有默认值，依次为：0，1，2，3。。。 声明时可以另行定义枚举元素的值# Enum Weekday {SUM=7,MON=1,TUE,WED,THU,FRI,SAT}; //后面从TUE依次为23456 枚举值可以进行关系运算 整数值不能直接赋值给枚举变量，如需将整数值给枚举类型，需要进行强制转换##例题【书上2-11】###【问题描述】设某次体育比赛的结果有四种可能：WIN,LOSE,TIE,CANCEL，编写程序输出这四种情况###【分析】比赛结果只有这四种，所以可以使用枚举类型来存放比赛结果###【代码】 #include using namespace std; enum Game{WIN,LOSE,TIE,CANCEL}; int main() { Game gameResult,omit=CANCEL; for (int i = WIN; i &lt;= CANCEL; i++) { //隐含类型转换 gameResult = Game(i); //显式类型转换 if (gameResult == omit) cout &lt;&lt; endl&lt;&lt;&quot;the game was canceled.&quot; &lt;&lt; endl; else { cout &lt;&lt; &quot;the game was played. &quot;; if (gameResult == WIN) cout &lt;&lt; &quot;we won!!&quot; &lt;&lt; endl; if (gameResult == LOSE) cout &lt;&lt; &quot;we lost..&quot; &lt;&lt; endl; } } return 0; }## ## #三、枚举类型的应用# ##例题【书上2-34】 ###【问题描述】口袋中有红、黄、蓝、白、黑 5种颜色的球若干，每次从口袋中拿出三个不同颜色，问有多少种取法。 ###【分析】由于球只能是五种颜色之一，故可用枚举类型表示球的颜色。设取出的球为i、j、k，根据题意，i、j、k分别可以有五种取值，且i≠j≠k。可以用穷举法，逐个检验每一种可能的组合，从中找出符合要求的组合并输出。 ###【代码】 #include&lt;iostream&gt; using namespace std; int print(int x) { //借助函数输出每种结果 switch (x) { case 0:cout &lt;&lt; &quot;RED &quot;; break; case 1:cout &lt;&lt; &quot;YELLOW &quot;; break; case 2:cout &lt;&lt; &quot;BLUE &quot;; break; case 3:cout &lt;&lt; &quot;WHITE &quot;; break; case 4:cout &lt;&lt; &quot;BLACK &quot;; break; } return 0; } int main() { enum color { RED, YELLOW, BLUE, WHITE, BLACK }; //定义枚举类型 int i, j, k, n = 0; for (i = RED; i &lt;= BLACK; i++) for (j = i + 1; j &lt;= BLACK; j++) for (k = j + 1; k &lt;= BLACK; k++) { n++; print(i); print(j); print(k); cout &lt;&lt; endl; } cout &lt;&lt; &quot;共有&quot; &lt;&lt; n &lt;&lt; &quot;种&quot;; return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"C++","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"第三章总结：函数","slug":"第三章笔记-函数","date":"2019-11-29T14:16:01.000Z","updated":"2020-05-28T05:24:37.681Z","comments":true,"path":"2019/11/29/第三章笔记-函数/","link":"","permalink":"/2019/11/29/第三章笔记-函数/","excerpt":"","text":"#一、为什么要使用函数？ ####1. 简化代码，增强程序的可读性。把一些计算或操作编成通用的函数，以供随时调用，从而避免了代码的重复冗长；简化代码量，对各个部分进行封装，使问题变得简单而且直观，提高了程序的易读性。 ####2.提升程序的可维护性。如果我们把主程序拆分成许多个步骤，为每一个功能编写一个函数，那么根据函数的函数名每个函数的功能就非常清晰了。如果我们要修改某一个函数的功能，其他的函数也丝毫不会受到影响。 ####3.提高团队的开发效率。设计一个规模很大的程序，它有几千项功能，若把他们都放在一个主函数里，就只能由一个人来编写。但如果我们把这几千项功能分拆为一些函数，分给几百个人去编写，最后用主函数把这些完成的函数组织一下，一个程序就可以很快完工。 ####4.降低程序执行效率。【缺点】在程序中运用函数，就需要传递参数，开辟缓存、堆栈等，相比较而言，这个歌过程会耗一些多余的效率。 #二、为什么要用函数重载？ ###【定义】两个以上的函数，具有相同的函数名，但是形参的个数或者类型不同，编译器根据形参和实参的类型和个数的最佳匹配，自动确定调用哪一个函数，称作函数的重载。 重载函数的形参必须不同（形参个数不同或者类型不同） 与返回值的类型无关###【使用函数重载的好处】重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。当函数的编写者充分考虑了不同情况下应该运行稍有不同的函数，函数的使用者就不必为这些小细节而烦恼了。###【注意】当使用具有默认形参值的函数重载形式时，需要注意防止二义性 void fun(int length,int weight = 2,int height = 33); //由于weight和height具有默认初始值，只需要一个参数length即可调用函数 void fun(int length); //只需要参数length即可调用函数 /*此时，对于语句fun（1），编译器会指出语法错误*/ #三、值传递 VS 地址传递 VS 引用传递 ##1.值传递形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。 int fun（int x）； ##2.地址传递形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作 int fun（int *x）； ##3.引用传递形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 int fun（int &amp;x）； ##4.三种传递方式的比较 ###【代码】分析三种传值方式函数操作地址的不同 #include &lt; iostream &gt; using namespace std; //值传递void change1(int n) { cout &lt;&lt; “值传递–函数操作地址” &lt;&lt; &amp;n &lt;&lt; endl; //显示的是拷贝的地址而不是源地址 n++;} //引用传递void change2(int&amp; n) { cout &lt;&lt; “引用传递–函数操作地址” &lt;&lt; &amp;n &lt;&lt; endl; //显示的是源地址（即引用为别名） n++;}//指针传递void change3(int n) { cout &lt;&lt; “指针传递–函数操作地址 “ &lt;&lt; n &lt;&lt; endl; //显示的是源地址 n = *n + 1;}int main() { int n = 10; cout &lt;&lt; “ n的地址” &lt;&lt; &amp;n &lt;&lt; endl&lt;&lt; endl; change1(n); cout &lt;&lt; “值传递结果 n=” &lt;&lt; n &lt;&lt; endl&lt;&lt; endl; change2(n); cout &lt;&lt; “引用传递结果 n=” &lt;&lt; n &lt;&lt; endl&lt;&lt; endl; change3(&amp;n); cout &lt;&lt; “地址传递结果 n=” &lt;&lt; n &lt;&lt; endl&lt;&lt; endl; return true;} ###【结论】 当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。 当函数内部需要修改参数并且希望改动影响调用者时，采用引用传递或者地址传递。 当一个函数实际需要返回多个值，而只能显式返回一个值时，可以将另外需要返回的变量以地址或者引用传递给函数，这样在函数内部修改并且返回后，调用者可以拿到被修改过后的变量，也相当于一个隐式的返回值传递。##四、递归函数###【定义】一种可以直接或间接调用自身的函数（自己调用自己） 递归的边界 递归的逻辑–公式 ##【例1】阶乘 ###【分析】阶乘的递归公式为 ###【代码】 #include&lt; iostream &gt;using namespace std;int F(int n){ if(n==0)//递归边界 return 1; return n*F(n-1);//递归公式} int main(){ int n; cin &gt;&gt; n; cout &lt;&lt; F(n) &lt;&lt; endl; return 0;} ##【例2】汉诺塔 ###【分析】 1）n == 1 第1次 1号盘 A—-&gt;C sum = 1 次 2) n == 2 第1次 1号盘 A—-&gt;B 第2次 2号盘 A—-&gt;C 第3次 1号盘 B—-&gt;C sum = 3 次 3）n == 3 第1次 1号盘 A—-&gt;C 第2次 2号盘 A—-&gt;B 第3次 1号盘 C—-&gt;B 第4次 3号盘 A—-&gt;C 第5次 1号盘 B—-&gt;A 第6次 2号盘 B—-&gt;C 第7次 1号盘 A—-&gt;C sum = 7 次 假设A为存放盘子的塔，B为目标塔，C为辅助塔，算法分为三步： step1：将A上n-1个盘子全部放到C塔上 step2：将A上剩下的一个盘子放到B塔上 step3：将C塔上的盘子全部放到B塔上 ###【代码】 #include&lt;iostream&gt; using namespace std; void move(char src, char dest) { //移动函数 cout &lt;&lt; src &lt;&lt; &quot;--&gt;&quot; &lt;&lt; dest &lt;&lt; endl; } void hanoi(int n, char src, char mid, char dest) { if (n == 1) move(src, dest); else { hanoi(n - 1, src, dest, mid); //把上面的n-1个移动到备用柱子 move(src, dest); //把第n个移动到目标柱子 hanoi(n - 1, mid, src, dest); //把备用柱子上的n-1个移动到目标柱子 } } int main() { int m; cout &lt;&lt; &quot;enter the num:&quot;; //输入环个数 cin &gt;&gt; m; hanoi(m, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;); return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"函数","slug":"函数","permalink":"/tags/函数/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"第八章总结：多态性","slug":"第八章笔记-多态","date":"2019-11-29T14:16:01.000Z","updated":"2020-05-28T05:24:37.676Z","comments":true,"path":"2019/11/29/第八章笔记-多态/","link":"","permalink":"/2019/11/29/第八章笔记-多态/","excerpt":"","text":"#第八章 多态性 #一、多态性的各种概念 多态的定义：同样的消息被不同类型的对象接收时导致不同的行为 多态的类型：重载多态、强制多态、包含多态和参数多态。前两种为专用多态，后两种为通用多态。 [强制多态]：将一个变元的类型加以变化，以符合一个函数或者操作的要求。（例如：加法运算符在进行浮点数与整型数相加时，首先进行强制转换，把整型数先变为浮点型数再相加的情况） [多态的实现]：编译时的多态性（在编译过程中确定了同名操作的具体操作对象）和运行时的多态（在程序运行过程中才动态的确定操作所针对的具体对象） [绑定]：指计算机程序自身彼此关联的过程，就是把一个标识符名和一个地址绑定的过程 [静态绑定]：绑定工作在编译阶段完成的情况。 [动态绑定]：绑定在程序运行阶段完成的情况。 [运算符重载]：对已有的运算符赋予多重含义，使同一个运算符作用于不同类型的数据时导致的不同行为。 #二、运算符的重载实验 ##1.成员函数形式的重载 ###【复数的加减法】 /例题8-1//复数的加减法/ #includeusing namespace std; class complex {private: double real; //负数实部 double imag; //实数虚部public: complex(double r = 0.0, double i = 0.0) :real(r), imag(i) {} complex operator +(const complex&amp; c2) const; complex operator -(const complex&amp; c2) const; void display() const { cout &lt;&lt; “(“ &lt;&lt; real &lt;&lt; “,” &lt;&lt; imag &lt;&lt; “)” &lt;&lt; endl; }}; complex complex ::operator +(const complex&amp; c2) const { return complex(real + c2.real, imag + c2.imag);} complex complex ::operator -(const complex&amp; c2) const { return complex(real - c2.real, imag - c2.imag);} int main() { complex c1(5, 4), c2(2, 10), c3; cout &lt;&lt; “c1=”; c1.display(); cout &lt;&lt; “c2=”; c2.display(); c3 = c2 - c1; cout &lt;&lt; “c3=c2-c1=”; c3.display(); c3 = c2 + c1; cout &lt;&lt; “c3=c2+c1=”; c3.display(); } ###运行截图： ##2.非成员函数形式的重载（借助friend） ###【前置++和后置++的重载】 #includeusing namespace std; class Point {private: float x, y;public: Point(float x, float y) { this-&gt;x = x; this-&gt;y = y; } void show() { cout &lt;&lt; “point=(“ &lt;&lt; x &lt;&lt; “,” &lt;&lt; y &lt;&lt; “)” &lt;&lt; endl; } friend Point operator ++(Point p); //前置++ friend Point operator ++(Point &amp;p,int); //后置++}; Point operator++(Point p) { p.x++; p.y++; return p;} Point operator++(Point &amp;p,int) { Point old = p; p.x++; p.y++; return old;} int main() { Point p(2, 1.5); Point* pt = &p; p.show(); cout &lt;&lt; “run p++: “; (p++).show(); cout &lt;&lt; “run ++p: “; (++p).show(); return 0;} ###运行截图： ###【将==重载为判断两个字符串相等】 /附加题//重载 ==，判断两个字符串是否相等/ #include #include #includeusing namespace std;class My_string{public: char ch; My_string(char ch):ch(ch){} //构造函数 int operator ==(My_string s2)const; //重载 ==};int My_string::operator==(My_string s2)const { if (strcmp(ch, s2.ch) == 0)return 1; else return 0;}int main() { char *op1=new char[100], *op2=new char[100]; cout &lt;&lt; &quot;输入两个字符串：&quot;; cin &gt;&gt;op1&gt;&gt;op2; assert(strlen(op1) &lt;= 100 &amp;&amp; strlen(op2) &lt;= 100); //防止字符数组越界 My_string a(op1); My_string b(op2); if (a.operator==(b)) { cout &lt;&lt; &quot;两字符串相等&quot; &lt;&lt; endl; } else cout &lt;&lt; &quot;两字符串不等&quot; &lt;&lt; endl; delete[] op1; //删除字符串 delete[] op2; return 0; } ###运行截图： #三、虚函数的各种概念及实验验证 ##1.相关概念 [一般虚函数的声明语法]：vitual 函数类型 函数名 (形参表); 虚函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候。 [运行过程中多态需要满足的条件]：①满足赋值兼容原则②声明虚函数③由成员函数来调用或者是通过指针、引用来访问虚函数 [判断派生类的成员是不是虚函数]:①该函数是否与基类虚函数有相同的姓名字②该函数是否与基类的虚函数有相同的参数个数及相同的对应参数类型③该函数是否与基类的虚函数有相同的返回值或者满足赋值兼容性规则的指针、引用类型的返回值 只有通过基类的指针或者引用调用虚函数时，才会发生动态绑定 在重写继承来的虚函数时，如果函数有默认形参值，不要重新定义不同的值。原因是：虽然虚函数是动态绑定的，但默认形参值是静态绑定的。通过一个指向派生类的基类指针，可以访问到派生类的虚函数，但默认形参值只能来自基类的定义 [虚析构函数]：析构函数设置为虚函数后，在使用指针引用时会实现动态绑定，实现运行时的多态，保证使用基类类型的指针就可以调用适当的析构函数针对不同的对象进行清理工作 [纯虚函数的形式]：vitual 函数类型 函数名 (参数表) = 0； 声明为纯虚函数之后，基类中就可以不再给出函数的实现部分，纯虚函数的函数体由派生类给出。 [抽象类]：带有纯虚函数的类是抽象类。/抽象类不能实例化。##2.纯虚函数的应用/8-6//虚函数，求圆和长方形的面积及周长/#includeusing namespace std;#define pi 3.14 class Shape {public: virtual float getArea() = 0; //纯虚函数 virtual float getPerim() = 0; //纯虚函数}; class Circle :public Shape {private: float r;public: Circle(float r) { this-&gt;r = r; } float getArea() { return (float)pi r r; } float getPerim() { return (float)pi 2 r; } void show() { cout &lt;&lt; “Circle:” &lt;&lt; endl; cout &lt;&lt; “r=” &lt;&lt; r &lt;&lt; endl; }}; class Rectangle :public Shape {private: float width, height;public: Rectangle(float w, float h) { width = w; height = h; } float getArea() { return width height; } float getPerim() { return 2 (width + height); } void show() { cout &lt;&lt; “Rectangle:” &lt;&lt; endl; cout &lt;&lt; “w=” &lt;&lt; width &lt;&lt; “ h=” &lt;&lt; height &lt;&lt; endl; }}; int main() { Circle circle(2); Rectangle rectangle(3, 4); circle.show(); cout &lt;&lt; &quot;area = &quot; &lt;&lt; circle.getArea() &lt;&lt; &quot; perim = &quot; &lt;&lt; circle.getPerim() &lt;&lt; endl &lt;&lt; endl; rectangle.show(); cout &lt;&lt; &quot;area = &quot; &lt;&lt; rectangle.getArea() &lt;&lt; &quot; perim = &quot; &lt;&lt; rectangle.getPerim() &lt;&lt; endl &lt;&lt; endl; return 0; } ###运行截图： ##3.有无虚函数的区别 #includeusing namespace std; class BaseClass {public: virtual void fun1() { cout &lt;&lt; “BaseClass.fun1” &lt;&lt; endl; } void fun2() { cout &lt;&lt; “BaseClass.fun2” &lt;&lt; endl; }}; class Derived :public BaseClass {public: void fun1() { cout &lt;&lt; “Derived.fun1” &lt;&lt; endl; } void fun2() { cout &lt;&lt; “Derived.fun2” &lt;&lt; endl; }}; int main() { Derived d; Derived derived = &d; BaseClass base = &d; cout &lt;&lt; “通过base指针调用:” &lt;&lt; endl; base-&gt;fun1(); base-&gt;fun2(); cout &lt;&lt;endl&lt;&lt; “通过derived指针调用:” &lt;&lt; endl; derived-&gt;fun1(); derived-&gt;fun2(); return 0;} ###运行截图： #四、课后8-11题目解析 ##题目描述在此前基础上，通过继承Rectangle类得到Square。在Shape中增加一个函数int getVertexCount() const用来获得当前顶点的个数，并使用以下几个方法 ##（1）使用dynamic_cast实现Shape::getVertexCount函数 #includeusing namespace std; #define pi 3.14class Shape {public: virtual float getArea() = 0; virtual float getPerim() = 0; virtual int getVertexCount(Shape *s)const;}; class Circle :public Shape {private: float r;public: int VertexCount = 0; Circle(float r) { this-&gt;r = r; } float getArea() { return (float)pi r r; } float getPerim() { return (float)pi 2 r; } void show() { cout &lt;&lt; “Circle:” &lt;&lt; endl; cout &lt;&lt; “r=” &lt;&lt; r &lt;&lt; endl; }}; class Rectangle :public Shape {private: float width, height;public: int VertexCount = 4; Rectangle(float w, float h) { width = w; height = h; } float getArea() { return width height; } float getPerim() { return 2 (width + height); } void show() { cout &lt;&lt; “Rectangle:” &lt;&lt; endl; cout &lt;&lt; “w=” &lt;&lt; width &lt;&lt; “ h=” &lt;&lt; height &lt;&lt; endl; }}; class Square :public Rectangle {public: int VertexCount = 4; Square(float len) :Rectangle(len, len) { length = len; } float getArea() { return length length; } float getPerim() { return 4 length; } void show() { cout &lt;&lt; “Square:” &lt;&lt; endl; cout &lt;&lt; “length=” &lt;&lt; length &lt;&lt; endl; }private: float length;}; //使用dynamic_cast的方式实现求顶点函数int Shape::getVertexCount(Shape s)const { Rectangle r=dynamic_cast&lt;Rectangle&gt;(s); Circle c = dynamic_cast&lt;Circle&gt;(s); Square sq = dynamic_cast&lt;Square*&gt;(s); if (r) //如果可以转换 return r-&gt;VertexCount; if (c) return c-&gt;VertexCount ; if (sq) return sq-&gt;VertexCount; } int main() { Circle circle(2); Rectangle rectangle(3, 4); Square square(5); circle.show(); //圆 cout &lt;&lt; &quot;area = &quot; &lt;&lt; circle.getArea() &lt;&lt; &quot; perim = &quot; &lt;&lt; circle.getPerim() &lt;&lt; endl ; cout&lt;&lt;&quot;顶点个数：&quot;&lt;&lt;circle.getVertexCount(&amp;circle)&lt;&lt; endl&lt;&lt;endl; rectangle.show(); //长方形 cout &lt;&lt; &quot;area = &quot; &lt;&lt; rectangle.getArea() &lt;&lt; &quot; perim = &quot; &lt;&lt; rectangle.getPerim() &lt;&lt; endl; cout &lt;&lt;&quot;顶点个数&quot;&lt;&lt; rectangle.getVertexCount(&amp;rectangle) &lt;&lt; endl&lt;&lt;endl; square.show(); //正方形 cout &lt;&lt; &quot;area = &quot; &lt;&lt; square.getArea() &lt;&lt; &quot; perim = &quot; &lt;&lt; square.getPerim() &lt;&lt; endl; cout &lt;&lt; &quot;顶点个数&quot; &lt;&lt; square.getVertexCount(&amp;square) &lt;&lt; endl; return 0; } ##（2）使用typeid实现Shape::getVertexCount函数 #include #include #includeusing namespace std; #define pi 3.14class Shape {public: virtual float getArea() = 0; virtual float getPerim() = 0; int getVertexCount(Shape&amp;s)const;}; class Circle :public Shape {private: float r;public: Circle(float r) { this-&gt;r = r; } float getArea() { return (float)pi * r * r; } float getPerim() { return (float)pi * 2 * r; } void show() { cout &lt;&lt; &quot;Circle:&quot; &lt;&lt; endl; cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; endl; } }; class Rectangle :public Shape {private: float width, height;public: Rectangle(float w, float h) { width = w; height = h; } float getArea() { return width * height; } float getPerim() { return 2 * (width + height); } void show() { cout &lt;&lt; &quot;Rectangle:&quot; &lt;&lt; endl; cout &lt;&lt; &quot;w=&quot; &lt;&lt; width &lt;&lt; &quot; h=&quot; &lt;&lt; height &lt;&lt; endl; } }; class Square :public Rectangle {public: Square(float len) :Rectangle(len, len) { length = len; } float getArea() { return length length; } float getPerim() { return 4 length; } void show() { cout &lt;&lt; “Square:” &lt;&lt; endl; cout &lt;&lt; “length=” &lt;&lt; length &lt;&lt; endl; }private: float length;}; int Shape::getVertexCount(Shape&amp; s)const { if (!strcmp(typeid(s).name(), “class Circle”))return 0; else if (!strcmp(typeid(s).name(), “class Rectangle”) || !strcmp(typeid(s).name(), “class Square”))return 4; else return 1;} int main() { Circle circle(2); Rectangle rectangle(3, 4); Square square(5); circle.show(); //圆 cout &lt;&lt; &quot;area = &quot; &lt;&lt; circle.getArea() &lt;&lt; &quot; perim = &quot; &lt;&lt; circle.getPerim() &lt;&lt; endl; cout &lt;&lt; &quot;顶点个数：&quot; &lt;&lt; circle.getVertexCount(circle) &lt;&lt; endl &lt;&lt; endl; rectangle.show(); //长方形 cout &lt;&lt; &quot;area = &quot; &lt;&lt; rectangle.getArea() &lt;&lt; &quot; perim = &quot; &lt;&lt; rectangle.getPerim() &lt;&lt; endl; cout &lt;&lt; &quot;顶点个数&quot; &lt;&lt; rectangle.getVertexCount(rectangle) &lt;&lt; endl &lt;&lt; endl; square.show(); //正方形 cout &lt;&lt; &quot;area = &quot; &lt;&lt; square.getArea() &lt;&lt; &quot; perim = &quot; &lt;&lt; square.getPerim() &lt;&lt; endl; cout &lt;&lt; &quot;顶点个数&quot; &lt;&lt; square.getVertexCount(square) &lt;&lt; endl; return 0; } ##（3）将Shape::getVertexCount函数声明为虚函数，在派生类中给出具体实现 #includeusing namespace std; #define pi 3.14class Shape {public: virtual float getArea() = 0; virtual float getPerim() = 0; virtual int getVertexCount(Shape* s)const = 0;}; class Circle :public Shape {private: float r;public: int VertexCount = 0; Circle(float r) { this-&gt;r = r; } float getArea() { return (float)pi r r; } float getPerim() { return (float)pi 2 r; } void show() { cout &lt;&lt; “Circle:” &lt;&lt; endl; cout &lt;&lt; “r=” &lt;&lt; r &lt;&lt; endl; } int getVertexCount(Shape s)const { return VertexCount; }};class Rectangle :public Shape {private: float width, height;public: int VertexCount = 4; Rectangle(float w, float h) { width = w; height = h; } float getArea() { return width height; } float getPerim() { return 2 (width + height); } void show() { cout &lt;&lt; “Rectangle:” &lt;&lt; endl; cout &lt;&lt; “w=” &lt;&lt; width &lt;&lt; “ h=” &lt;&lt; height &lt;&lt; endl; } int getVertexCount(Shape s)const { return VertexCount; }}; class Square :public Rectangle {public: int VertexCount = 4; Square(float len) :Rectangle(len, len) { length = len; } float getArea() { return length length; } float getPerim() { return 4 length; } void show() { cout &lt;&lt; “Square:” &lt;&lt; endl; cout &lt;&lt; “length=” &lt;&lt; length &lt;&lt; endl; } int getVertexCount(Shape* s)const { return VertexCount; }private: float length;}; int main() { Circle circle(2); Rectangle rectangle(3, 4); Square square(5); circle.show(); //圆 cout &lt;&lt; &quot;area = &quot; &lt;&lt; circle.getArea() &lt;&lt; &quot; perim = &quot; &lt;&lt; circle.getPerim() &lt;&lt; endl; cout &lt;&lt; &quot;顶点个数：&quot; &lt;&lt; circle.getVertexCount(&amp;circle) &lt;&lt; endl &lt;&lt; endl; rectangle.show(); //长方形 cout &lt;&lt; &quot;area = &quot; &lt;&lt; rectangle.getArea() &lt;&lt; &quot; perim = &quot; &lt;&lt; rectangle.getPerim() &lt;&lt; endl; cout &lt;&lt; &quot;顶点个数&quot; &lt;&lt; rectangle.getVertexCount(&amp;rectangle) &lt;&lt; endl &lt;&lt; endl; square.show(); //正方形 cout &lt;&lt; &quot;area = &quot; &lt;&lt; square.getArea() &lt;&lt; &quot; perim = &quot; &lt;&lt; square.getPerim() &lt;&lt; endl; cout &lt;&lt; &quot;顶点个数&quot; &lt;&lt; square.getVertexCount(&amp;square) &lt;&lt; endl; return 0; } ##运行截图","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"多态性","slug":"多态性","permalink":"/tags/多态性/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"第七章总结：继承与派生","slug":"第七章笔记-继承与派生","date":"2019-11-29T14:16:01.000Z","updated":"2020-05-28T05:24:37.679Z","comments":true,"path":"2019/11/29/第七章笔记-继承与派生/","link":"","permalink":"/2019/11/29/第七章笔记-继承与派生/","excerpt":"","text":"#继承与派生———第七章总结作业 #一、继承和派生的相关基本概念 [类的继承]：新的类从已有的类得到已有的属性的过程 [类的派生]：从已有类产生新类的过程 原有的类称为[基类]或[父类]，新的类称为[派生类]或[子类] [多继承]：一个类可以有多个继承，反之只有一个继承的称为[单继承] //单继承 class 派生类名:继承方式 基类名{ 成员声明; } //多继承 class 派生类名:继承方式1 基类名,继承方式2 基类名...{ 成员声明; } 在类族中，直接参与派生出某类的基类称为[直接基类]；基类的基类甚至更高层的基类称为[间接基类] 继承与派生是为了提高代码的重用性和可扩充性。【好处】 通过继承实现设计与代码的重用，通过派生实现当新问题出现并且不能用原有设计解决时进行对原有类的改造【目的】 派生类的生成过程：1.吸收基类成员——吸收除去构造函数和析构函数之外的所有成员2.改造基类成员——如果派生类声明了一个和某些基类成员同名的新成员，派生类就会隐藏外层同名成员，这被称为[同名隐藏]3.添加新成员 [公有继承]：基类的公有成员public和保护类成员protected的访问属性在派生类中不变，而基类的私有成员private不可以直接访问 [私有继承]：基类的公有成员public和保护类成员protected在派生类中以私有成员身份出现，而基类的私有成员private不可以直接访问（即都作为派生类的私有成员） [保护继承]：基类的公有成员public和保护成员protected都以保护类成员身份出现在派生类中，基类私有成员private不可以直接访问 #二、3种继承方式的比较（public,private,protected） ##【公有继承】【7-1】 ###代码 //从基类继承的public、protected类型都可使用，private不能使用 #include&lt;iostream&gt; using namespace std; class Point { public: void initPoint(float x = 0, float y = 0) { this-&gt;x = x; this-&gt;y = y; } void move(float offX, float offY) { x += offX; y += offY; } float getX() const{ return x; } float getY() const{ return y; } private: float x, y; }; class Rectangle:public Point { public: void initRectangle(float x, float y, float w, float h) { initPoint(x, y); //调用基类公有数据成员 this-&gt;h = h; this-&gt;w = w; } float getW() const { return w; } float getH() const { return h; } private: //新增私有数据成员 float w, h; }; int main() { Rectangle rect; rect.initRectangle(2, 3, 20, 10); rect.move(3, 2); cout &lt;&lt; &quot;The data of rect(x,y,w,h):&quot; &lt;&lt; endl; cout &lt;&lt; rect.getX() &lt;&lt; &quot;,&quot; &lt;&lt; rect.getY() &lt;&lt; &quot;,&quot; &lt;&lt; rect.getW() &lt;&lt; &quot;,&quot; &lt;&lt; rect.getH() &lt;&lt; endl; return 0; } ###运行截图 ##【私有继承】【7-2】 ###代码 /7-2//私有继承/ #include&lt;iostream&gt; using namespace std; class Point { public: void initPoint(float x = 0, float y = 0) { this-&gt;x = x; this-&gt;y = y; } void move(float offX, float offY) { x += offX; y += offY; } float getX() const{ return x; } float getY() const{ return y; } private: float x, y; }; class Rectangle:private Point { //***************** public: void initRectangle(float x, float y, float w, float h) { initPoint(x, y); //调用基类公有数据成员 this-&gt;h = h; this-&gt;w = w; } void move(float offX, float offY) { Point::move(offX, offY); //*********************** } float getX() const { return Point::getX(); } //******************** float getY() const { return Point::getY(); } //******************** float getW() const { return w; } float getH() const { return h; } private: //新增私有数据成员 float w, h; }; int main() { Rectangle rect; rect.initRectangle(0, 0, 20, 10); rect.move(3, 2); cout &lt;&lt; &quot;The data of rect(x,y,w,h):&quot; &lt;&lt; endl; cout &lt;&lt; rect.getX() &lt;&lt; &quot;,&quot; &lt;&lt; rect.getY() &lt;&lt; &quot;,&quot; &lt;&lt; rect.getW() &lt;&lt; &quot;,&quot; &lt;&lt; rect.getH() &lt;&lt; endl; return 0; } ###运行截图 ##【保护继承】【7-3】 基类的公有成员和保护成员都以保护类成员身份出现在派生类中，基类私有成员不可以直接访问 派生类的其他成员可以直接访问从基类继承来的公有成员和保护成员，但在类的外部通过派生类的对象无法直接访问他们 如果B是A的派生类，B的成员函数只能通过B的对象访问A中定义的protected成员，而不能通过A的对象访问A中的protected对象###代码 #include #include&lt;assert.h&gt; using namespace std; class A { public: int a; A() { a1 = 1; a2 = 2; a3 = 3; a = 4; } void fun() { cout &lt;&lt; a &lt;&lt; endl; //正确 cout &lt;&lt; a1 &lt;&lt; endl; //正确 cout &lt;&lt; a2 &lt;&lt; endl; //正确 cout &lt;&lt; a3 &lt;&lt; endl; //正确 } public: int a1; protected: int a2; private: int a3; }; class B : protected A { public: int a; B(int i) { A(); a = i; } void fun() { cout &lt;&lt; a &lt;&lt; endl; //正确，public成员。 cout &lt;&lt; a1 &lt;&lt; endl; //正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。 cout &lt;&lt; a2 &lt;&lt; endl; //正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。 cout &lt;&lt; a3 &lt;&lt; endl; //错误，基类的private成员不能被派生类访问。 } }; int main() { B b(10); cout &lt;&lt; b.a &lt;&lt; endl; //正确。public成员 cout &lt;&lt; b.a1 &lt;&lt; endl; //错误，protected成员不 能在类外访问。 cout &lt;&lt; b.a2 &lt;&lt; endl; //错误，protected成员不能在类外访问。 cout &lt;&lt; b.a3 &lt;&lt; endl; //错误，private成员不能在类外访问。 system(&quot;pause&quot;); return 0; } ###运行截图 #三、派生类的构造函数执行顺序浅析 ##【构造函数】 构造派生类对象时，需要对基类的成员对象和新增成员对象进行初始化 一般语法为： 派生类名::派生类名(参数表):基类名1(基类1初始化列表),...,基类n(基类n初始化列表),成员对象1(成员对象1初始化列表)... { 派生类构造函数的其他初始化操作; } 如果对基类进行初始化时，需要调用基类的带有形参表的构造函数时，必须声明构造函数 派生类构造函数执行的一般次序1.调用基类构造函数2.对派生类新增的成员对象初始化，调用顺序按照它们在类中的声明顺序3.执行派生类的构造函数内容 ###代码 //7-4 派生类构造函数，多继承，含有内嵌对象 #include&lt;iostream&gt; using namespace std; class B1 { //基类B1，构造函数有参数 public: B1(int i) { cout &lt;&lt; &quot;构造函数B1&quot; &lt;&lt; i &lt;&lt; endl; } }; class B2 { //基类B2，构造函数有参数 public: B2(int j) { cout &lt;&lt; &quot;构造函数B2&quot; &lt;&lt; j &lt;&lt; endl; } }; class B3 { //基类B3，构造函数无参数 public: B3() { cout &lt;&lt; &quot;构造函数B3*&quot; &lt;&lt; endl; } }; class Derived :public B2, public B1, public B3 { //声明派生类，顺序为B2,B1,B3 public: Derived(int a,int b,int c,int d):B1(a),menber2(d),menber1(c),B2(b){} //注意类名的个数与顺序，注意成员对象名的个数与顺序 private: B1 menber1; B2 menber2; B3 menber3; }; int main() { Derived obj(1, 2, 3, 4); return 0; } ###运行截图 ###代码解析1.关于Derived类构造函数的执行情况：先调用基类的构造函数，然后调用内嵌对象的构造函数，又因基类的调用顺序按照派生类的定义顺序，所以先B2，再是B1最后B3，而内嵌对象的调用顺序是按照成员在类中声明的顺序，所以先B1，后B2、B32.因为B3的构造函数没有参数，所以基类B3和基类B3的类成员对象menber3就不必列出","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"继承与派生","slug":"继承与派生","permalink":"/tags/继承与派生/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"第五章总结：静态数据成员和静态成员函数","slug":"第五章笔记-静态数据成员和静态成员函数 ","date":"2019-11-29T14:16:01.000Z","updated":"2020-05-28T05:24:37.671Z","comments":true,"path":"2019/11/29/第五章笔记-静态数据成员和静态成员函数 /","link":"","permalink":"/2019/11/29/第五章笔记-静态数据成员和静态成员函数 /","excerpt":"","text":"#第五章笔记—静态数据成员和静态成员函数 【背景】面向对象的设计方法兼容数据的保护和共享，静态成员的提出是为了解决不同对象之间数据共享问题的。例如要统计人员个数，出现次数等等都需要用到静态处理。 ###【定义】静态成员，指的是在c++类中声明成员时可以加上static关键字，这样声明的成员就叫做静态成员（包括静态数据成员和静态成员函数）。 ##静态数据成员 ###【声明格式】 static 数据类型 数据成员名; ###【说明】 在c++中，静态数据成员是属于类的，一旦声明某个数据成员为静态数据成员，则该类的每个对象都可以访问它。 为什么使用静态数据成员而不是全局变量？–因为全局变量会带来不安全性，并且破坏了面向对象程序设计的信息隐蔽性和封装性的特点。 在一个类中，无论建立多少个对象，都只有一个是静态数据成员的拷贝，从而实现了一个类的不同对象之间的数据共享。 静态数据成员的初始化必须要在类外单独初始化，并且初始化要在定义对象之前。 数据类型 类名：：静态数据成员名=初始值; 静态数据成员属于类，而不属于某个对象。###【代码验证】【书上5-4】【解析】point具有静态数据成员count++，第一次调用时输出1，第二次调用时输出2 #include using namespace std; class point { public: point(int x = 0, int y = 0) :x(x), y(y) { count++; } point(point&amp; p) { //复制构造函数 x = p.x; y = p.y; count++; } ~point() { //析构函数 count--; } void getX() { cout &lt;&lt; x; } void getY() { cout &lt;&lt; y; } void showcount() { cout &lt;&lt; &quot;count=&quot; &lt;&lt; count &lt;&lt; endl; } private: int x, y; static int count;//声明静态数据成员 }; int point::count = 0;//用类名限定静态成员定义和初始化 int main() { point a(1, 1); a.showcount(); point b(a); b.showcount(); return 0; } 【运行截图】 ##静态函数成员 ###【声明格式】 static 返回类型 静态成员函数名 (实参表); ###【调用格式】 类名：：静态成员函数名(实参表); //—-1对象.静态成员函数名(实参表); //—-2对象指针-&gt;静态成员函数名(实参表);//—-3 ###【说明】 静态成员函数属于类，不属于该类的某个对象，为该类所有对象共享 私有静态成员函数不能被类外部的函数和对象访问 使用静态成员函数的原因是可以用它在建立任何对象之前调用静态成员函数，从而对静态数据成员进行处理，但这一功能是普通成员函数所不能做到的。 静态成员函数与非静态成员函数的区别是：静态成员函数属于类，没有this指针，而非静态成员函数属于该类的某一对象，有指向该对象的this指针。 静态成员函数在类外可以直接通过类访问或者通过对象访问，而非静态成员函数在类外只能通过对象访问。 类名：：静态成员函数名();//在类外直接访问静态成员函数 静态成员函数只能访问本类中的静态数据成员 vs 非静态成员函数可以访问本类中的静态数据成员与非静态数据成员。 ###【代码验证】【书上5-5】【解析】 #include&lt;iostream&gt; using namespace std; class Point { public: Point(int x = 0, int y = 0) :x(x), y(y) {//构造函数 count++; } Point(Point&amp; p) { //复制构造函数 x = p.x; y = p.y; count++; } ~Point() { count--; } int getX() { return x; } int getY() { return y; } static void showcount() { //静态成员函数 cout &lt;&lt; &quot;object count:&quot;&lt;&lt;count; } private: int x; int y; static int count; }; int Point::count = 0; int main() { Point a(4, 5); cout &lt;&lt;&quot;Point a:&quot;&lt;&lt; a.getX ()&lt;&lt; &quot; &quot; &lt;&lt; a.getY()&lt;&lt;endl; Point::showcount(); cout &lt;&lt; endl; Point b(a); cout &lt;&lt; &quot;Point b:&quot; &lt;&lt; a.getX() &lt;&lt; &quot; &quot; &lt;&lt; a.getY() &lt;&lt; endl; Point::showcount(); return 0; } ###【实际应用】【题目描述】 请编写程序，计算出当日此商品的总销售款sum以及每件商品的平均售价。要求用静态数据成员和静态成员函数。(提示: 将折扣discount，总销售款sum和商品销售总件数n声明为静态数据成员，再定义静态成员函数average(求平均售价)和display(输出结果)。【代码】 #includeusing namespace std;class Product {public: void set_value(); //设置商品的price和单次销售数量num void total(); //计算总销售额sum和销售总量total_num static void ave_count(); //计算平均商品价格 static void display(); // 显示sum,total_num和 averageprivate: int num; double price; static double discount; //折扣 static int total_num; //总销量 static double sum; //总销售额 static double average; //平均价格}; /数据初始化/double Product::discount=0.98;int Product::total_num=0;double Product::sum=0;double Product::average=0; void Product::set_value(){ cout &lt;&lt; “输入销量num和产品价格price：”; cin&gt;&gt;num&gt;&gt;price;}void Product::total(){ total_num+=num; if(num&gt;10) sum+=numpricediscount; else sum+=num*price;}void Product::ave_count(){ average=sum/total_num;}void Product::display(){ cout&lt;&lt;”num=”&lt;&lt;total_num&lt;&lt;endl &lt;&lt;”sum=”&lt;&lt;sum&lt;&lt;endl &lt;&lt;”average=”&lt;&lt;average&lt;&lt;endl;} int main(){ const int t=3; Product p[t]; for(int i=0;i&lt;t;i++){ p[i].set_value(); p[i].total(); } Product::ave_count(); Product::display(); return 0;}【运行截图】","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"C++","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-05-27T17:47:07.463Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}